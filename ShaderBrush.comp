/*
Compute Shader for brushing operations on mesh

author: Andrea Cipollini
*/

#version 460 core

struct Vertex
{
    float[3] Position;
    float[3] Normal;
    float[2] TexCoords;
    float[3] Tangent;
    float[3] Bitangent;
    uint NeighboursIndex;
    uint NeighboursNumber;
};

struct Intersection
{
    float[3] Position;
    float[3] Normal;
    bool hit;
    uint idxv0, idxv1, idxv2;
};

// 128 thread for each block
layout(local_size_x = 128) in;

// vertices coordinates input
layout(std430, binding = 0) buffer MeshDataInput
{
    Vertex Vertices[];
};

layout(std430, binding = 2) buffer IntersectionDataOutput
{
    Intersection IntersectionData;
};

// vertices coordinates input
layout(std430, binding = 3) buffer NeighboursDataInput
{
    uint Neighbours[];
};

/*
// intersection data input
layout(std430, binding = 1) buffer Intersection
{
    vec3 IntersectionPosition;
    vec3 IntersectionNormal;
    int IntersectedPrimitive;
};
*/

// uniforms
uniform float Strength;
uniform float Radius;
uniform uint VerticesNumber;

// temp uniforms
//uniform vec3 IntersectionPosition;
//uniform vec3 IntersectionNormal;

// Gaussian Distribution function applied to a pair of vertices with distribution height = strength and distribution "range" = radius
float GaussianDistribution(vec3 origin, vec3 position, float strength, float radius)
{
  float pi = 3.1415926535;
  float stdDev = 1.5;

  float N = 1.0 / ((stdDev * stdDev * stdDev) * sqrt((2.0 * pi) * (2.0 * pi) * (2.0 * pi)));
  N = N * (strength * 0.2 * radius);
  float dx = (origin.x - position.x) * 4.0 / radius;
  float dy = (origin.y - position.y) * 4.0 / radius;
  float dz = (origin.z - position.z) * 4.0 / radius;
  float E = ((dx * dx) + (dy * dy) + (dz * dz)) / (2 * stdDev * stdDev);
  
  return N * exp(-E);
}

vec3 GaussianBrush(vec3 position)
{
    /*
    float dist = distance(position, IntersectionPosition);
    if (dist <= Radius)
    {
        float displacement = GaussianDistribution(IntersectionPosition, position, Strength, Radius);
        vec3 newPosition = position + IntersectionNormal * displacement;

        return newPosition;
    }
    */
    vec3 interNormal = vec3(IntersectionData.Normal[0], IntersectionData.Normal[1], IntersectionData.Normal[2]);
    vec3 interPosition = vec3(IntersectionData.Position[0], IntersectionData.Position[1], IntersectionData.Position[2]);

    return position + interNormal * GaussianDistribution(interPosition, position, Strength, Radius);;
}

vec3 UniformBrush(vec3 position, vec3 normal)
{
    //float dist = length(Vertices[idx].Position - IntersectionPosition);
    //if (dist <= Radius)
    /*
    vec3 position = vec3(Vertices[idx].Position[0], Vertices[idx].Position[1], Vertices[idx].Position[2]);
    vec3 normal = vec3(Vertices[idx].Normal[0], Vertices[idx].Normal[1], Vertices[idx].Normal[2]);
    position = position + normal * 0.0001;
    Vertices[idx].Position[0] = position.x;
    Vertices[idx].Position[1] = position.y;
    Vertices[idx].Position[2] = position.z;
    */
    return position + normal * 0.0001;
    //Vertices[idx].Position = Vertices[idx].Position
    //Vertices[idx].Position = Vertices[idx].Position * 1.001;
}

vec3 GaussianBrush(vec3 position, vec3 normal)
{
    vec3 interPosition = vec3(IntersectionData.Position[0], IntersectionData.Position[1], IntersectionData.Position[2]);

    return position + normal * GaussianDistribution(interPosition, position, Strength, Radius);;
}

vec3 SmoothNormal(vec3 position, vec3 normal, uint index, uint neighboursNumber)
{
    vec3 newNormal = vec3(0.0, 0.0, 0.0);

    for (uint i = index; i < index + neighboursNumber - 1; i += 2)
    {
        uint j = Neighbours[i];
        uint k = Neighbours[i + 1];
        vec3 e1 = vec3(Vertices[j].Position[0], Vertices[j].Position[1], Vertices[j].Position[2]) - position;
        vec3 e2 = vec3(Vertices[k].Position[0], Vertices[k].Position[1], Vertices[k].Position[2]) - position;

        vec3 faceNormal = cross(e1, e2);
        float angleDot = dot(e1, e2);
        if (dot(faceNormal, normal) < 0.0)
            faceNormal = -faceNormal;
        
        newNormal = newNormal + faceNormal * acos((e1 * e2) / (length(e1) * length(e2)));
    }

    // check orientation
    float check = dot(normal, newNormal);
    if (check < 0.0)
        newNormal = -newNormal;

    return normalize(newNormal);
}

void main()
{
    // index
    uint idx = gl_GlobalInvocationID.x;
    
    // index check
    if (idx >= VerticesNumber)
        return;
    
    // vertex data
    vec3 position = vec3(Vertices[idx].Position[0], Vertices[idx].Position[1], Vertices[idx].Position[2]);
    vec3 normal = vec3(Vertices[idx].Normal[0], Vertices[idx].Normal[1], Vertices[idx].Normal[2]);

    //vec3 newPosition = UniformBrush(position, normal);
    //vec3 newPosition = GaussianBrush(position);
    vec3 newPosition = GaussianBrush(position);

    // assignement of new values
    Vertices[idx].Position[0] = newPosition.x;
    Vertices[idx].Position[1] = newPosition.y;
    Vertices[idx].Position[2] = newPosition.z;

    // we want the new positions to update the normals
    memoryBarrierShared();

    // smooth normal update
    vec3 newNormal = SmoothNormal(newPosition, normal, Vertices[idx].NeighboursIndex, Vertices[idx].NeighboursNumber);
    Vertices[idx].Normal[0] = newNormal.x;
    Vertices[idx].Normal[1] = newNormal.y;
    Vertices[idx].Normal[2] = newNormal.z;
}
