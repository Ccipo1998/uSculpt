/*
Compute Shader for brushing operations on mesh

author: Andrea Cipollini
*/

#version 460 core

struct Vertex
{
    float[3] Position;
    float[3] Normal;
    float[2] TexCoords;
    float[3] Tangent;
    float[3] Bitangent;

};

// 128 thread for each block
layout(local_size_x = 1024) in;

// vertices coordinates input
layout(std430, binding = 0) buffer MeshDataInput
{
    Vertex Vertices[];
};

/*
// intersection data input
layout(std430, binding = 1) buffer Intersection
{
    vec3 IntersectionPosition;
    vec3 IntersectionNormal;
    int IntersectedPrimitive;
};
*/

// uniforms
uniform float Strength;
uniform float Radius;
uniform uint VerticesNumber;

// temp uniforms
uniform vec3 IntersectionPosition;
uniform vec3 IntersectionNormal;

// Gaussian Distribution function applied to a pair of vertices with distribution height = strength and distribution "range" = radius
float GaussianDistribution(vec3 origin, vec3 position, float strength, float radius)
{
  float pi = 3.1415926535;
  float stdDev = 1.5;

  float N = 1.0 / ((stdDev * stdDev * stdDev) * sqrt((2.0 * pi) * (2.0 * pi) * (2.0 * pi)));
  N = N * (strength * 0.2 * radius);
  float dx = (origin.x - position.x) * 4.0 / radius;
  float dy = (origin.y - position.y) * 4.0 / radius;
  float dz = (origin.z - position.z) * 4.0 / radius;
  float E = ((dx * dx) + (dy * dy) + (dz * dz)) / (2 * stdDev * stdDev);
  
  return N * exp(-E);
}

vec3 GaussianBrush(vec3 position)
{
    /*
    float dist = distance(position, IntersectionPosition);
    if (dist <= Radius)
    {
        float displacement = GaussianDistribution(IntersectionPosition, position, Strength, Radius);
        vec3 newPosition = position + IntersectionNormal * displacement;

        return newPosition;
    }
    */
    return position + IntersectionNormal * GaussianDistribution(IntersectionPosition, position, Strength, Radius);;
}

vec3 UniformBrush(vec3 position, vec3 normal)
{
    //float dist = length(Vertices[idx].Position - IntersectionPosition);
    //if (dist <= Radius)
    /*
    vec3 position = vec3(Vertices[idx].Position[0], Vertices[idx].Position[1], Vertices[idx].Position[2]);
    vec3 normal = vec3(Vertices[idx].Normal[0], Vertices[idx].Normal[1], Vertices[idx].Normal[2]);
    position = position + normal * 0.0001;
    Vertices[idx].Position[0] = position.x;
    Vertices[idx].Position[1] = position.y;
    Vertices[idx].Position[2] = position.z;
    */
    return position + normal * 0.0001;
    //Vertices[idx].Position = Vertices[idx].Position
    //Vertices[idx].Position = Vertices[idx].Position * 1.001;
}

void main()
{
    // vertex data
    uint idx = gl_GlobalInvocationID.x;
    vec3 position = vec3(Vertices[idx].Position[0], Vertices[idx].Position[1], Vertices[idx].Position[2]);
    vec3 normal = vec3(Vertices[idx].Normal[0], Vertices[idx].Normal[1], Vertices[idx].Normal[2]);

    // index check
    //if (idx < VerticesNumber)
    //vec3 newPosition = UniformBrush(position, normal);
    vec3 newPosition = GaussianBrush(position);

    // assignement of new values
    Vertices[idx].Position[0] = newPosition.x;
    Vertices[idx].Position[1] = newPosition.y;
    Vertices[idx].Position[2] = newPosition.z;
}
