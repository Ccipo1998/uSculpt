/*
Compute Shader for brushing operations on mesh

author: Andrea Cipollini
*/

#version 460 core

struct Vertex
{
    vec3 Position;
    vec3 Normal;
    vec2 TextCoords;
    vec3 Tangent;
    vec3 Bitangent;
};

// 128 thread for each block
layout(local_size_x = 570) in;

// vertices coordinates input
layout(std430, binding = 0) buffer MeshDataInput
{
    Vertex Vertices[];
};

/*
// intersection data input
layout(std430, binding = 1) buffer Intersection
{
    vec3 IntersectionPosition;
    vec3 IntersectionNormal;
    int IntersectedPrimitive;
};
*/

// uniforms
uniform float Strength;
uniform float Radius;
uniform uint VerticesNumber;

// temp uniforms
uniform vec3 IntersectionPosition;
uniform vec3 IntersectionNormal;

// Gaussian Distribution function applied to a pair of vertices with distribution height = strength and distribution "range" = radius
float GaussianDistribution(vec3 origin, vec3 position, float strength, float radius)
{
  float pi = 3.1415926535;
  float stdDev = 1.5;

  float N = 1.0 / ((stdDev * stdDev * stdDev) * sqrt((2.0 * pi) * (2.0 * pi) * (2.0 * pi)));
  N = N * (strength * 0.2 * radius);
  float dx = (origin.x - position.x) * 4.0 / radius;
  float dy = (origin.y - position.y) * 4.0 / radius;
  float dz = (origin.z - position.z) * 4.0 / radius;
  float E = ((dx * dx) + (dy * dy) + (dz * dz)) / (2 * stdDev * stdDev);
  
  return N * exp(-E);
}

void GaussianBrush(uint idx)
{
    float dist = distance(Vertices[idx].Position, IntersectionPosition);
    if (dist <= Radius)
        Vertices[idx].Position = Vertices[idx].Position + IntersectionNormal * GaussianDistribution(IntersectionPosition, Vertices[idx].Position, Strength, Radius);
}

void UniformBrush(uint idx)
{
    float dist = length(Vertices[idx].Position - IntersectionPosition);
    //if (dist <= Radius)
    Vertices[idx].Position = Vertices[idx].Position + Vertices[idx].Normal * 0.0001;
    //Vertices[idx].Position = Vertices[idx].Position
    //Vertices[idx].Position = Vertices[idx].Position * 1.001;
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    // index check
    //if (idx < VerticesNumber)
    UniformBrush(idx);
}
